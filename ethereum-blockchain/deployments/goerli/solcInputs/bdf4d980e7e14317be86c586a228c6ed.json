{
  "language": "Solidity",
  "sources": {
    "contracts/AuctionContracts.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"@chainlink/contracts/src/v0.8/KeeperCompatible.sol\";\nimport \"../libraries/AuctionUtility.sol\";\n\nerror AuctionRegistry_RestrictedOwnerAccess();\nerror AuctionRegistry_RestrictedContractFactoryAccess();\nerror AuctionRegistry__RestrictedManagerAccess();\nerror AuctionRegistry__AuctionOngoing();\n\nerror Auction_RestrictedSellerAccess();\nerror Auction_NotInPendingPaymentState();\nerror Auction_RestrictedWinnerPaymentAccess();\nerror Auction_SelfBiddingIsNotAllowed();\nerror Auction_NoProceeds();\nerror Auction_UnauthorizedAccess();\n\nerror ContractFactory__RestrictedManagerAccess();\nerror ContractFactory_RestrictedOwnerAccess();\nerror ContractFactory_AuctionOngoing();\n\n/*\n1. Seller can register a new vehicle by minting a vehicle NFT\n2. Seller can host an auction for vehicles NFT that they own by creating a new BiddingHost contract\n3. BiddingHost can call HAP to emit events \n    to record each bid, extend bid end time, end bid, and record pending payments\n4. Chainlink Keeper is needed for automated end bid + refund deposit, lock contract + send deposit to HAP owner\n5. Chainlink Oracle is needed to fetch the latest usd -> eth rate\n*/\ncontract ContractFactory {\n    address public immutable owner;\n    address public auctionManagerAddress;\n    address public auctionRegistryAddress;\n    AuctionManager private auctionManager;\n    AuctionRegistry private auctionRegistry;\n    bool public emptyAucInRegistry;\n    address public aucFoundInRegistry;\n\n    constructor(address _auctionRegistryAddress) {\n        owner = msg.sender;\n        auctionRegistryAddress = _auctionRegistryAddress;\n        auctionRegistry = AuctionRegistry(_auctionRegistryAddress);\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) {\n            revert ContractFactory_RestrictedOwnerAccess();\n        }\n        _;\n    }\n\n    modifier onlyAuctionManager() {\n        if (msg.sender != auctionManagerAddress) {\n            revert ContractFactory__RestrictedManagerAccess();\n        }\n        _;\n    }\n\n    function getContractType() public pure returns (Constants.ContractType) {\n        return Constants.ContractType.CONTRACT_FACTORY;\n    }\n\n    function setAuctionManagerAddress(address _auctionManagerAddress)\n        public\n        onlyOwner\n    {\n        auctionManagerAddress = _auctionManagerAddress;\n        auctionManager = AuctionManager(auctionManagerAddress);\n    }\n\n    function createAuction(\n        address _seller,\n        address _nftAddress,\n        uint256 _tokenId,\n        address _eventEmitterAddress,\n        address _auctionKeeperAddress\n    ) public onlyAuctionManager {\n        // TODO: check if existing auction is registered in AuctionRegistry, \n            // if yes, check if auction state !== closed\n                // if yes, revert\n        address currAuction = auctionRegistry.auctionListings(_nftAddress, _tokenId);\n        aucFoundInRegistry = currAuction;\n\n        if (currAuction != address(0x0)) {\n            emptyAucInRegistry = false;\n            Auction tempAuction = Auction(currAuction);\n            Auction.AuctionState currState = tempAuction.currAuctionState();\n            // if event not in auction keepers or (event not in closed state and in registered state), unable to create a same auction for the NFT\n            if (currState != Auction.AuctionState.AUCTION_CLOSED) {\n                revert ContractFactory_AuctionOngoing();\n            }\n        }\n        emptyAucInRegistry = true;\n        \n        // call AuctionRegistry, register auction\n        // create Auction contract\n        Auction newAuctionInstance = new Auction(\n            owner,\n            _seller,\n            auctionManagerAddress,\n            _eventEmitterAddress,\n            _auctionKeeperAddress,\n            _nftAddress,\n            _tokenId\n        );\n\n        auctionRegistry.registerAuction(\n            _nftAddress,\n            _tokenId,\n            address(newAuctionInstance)\n        );\n    }\n}\n\ncontract EventEmitter {\n    modifier onlyAuction(address _senderAddress) {\n        require(\n            (AuctionUtility.getContractType(_senderAddress) ==\n                Constants.ContractType.AUCTION),\n            \"eventEmit can only be called by Auction\"\n        );\n        _;\n    }\n\n    event AuctionRegistered(\n        address indexed auction,\n        address seller,\n        address indexed nftAddress,\n        uint256 indexed tokenId,\n        uint256 registerTime\n    );\n\n    event AuctionStartedBidding(\n        address indexed auction,\n        address seller,\n        address indexed nftAddress,\n        uint256 indexed tokenId,\n        uint256 depositWei,\n        uint256 bidStartTime,\n        uint256 bidEndTime,\n        uint256 startingBid\n    );\n\n    event AuctionVerifyingWinner(\n        address indexed auction,\n        address seller,\n        address indexed nftAddress,\n        uint256 indexed tokenId,\n        address winner,\n        uint256 winningBid,\n        uint256 platformCharge,\n        uint256 startTime,\n        uint256 endTime\n    );\n\n    event AuctionPendingPayment(\n        address indexed auction,\n        address seller,\n        address indexed nftAddress,\n        uint256 indexed tokenId,\n        address winner,\n        uint256 winningBid,\n        uint256 startTime,\n        uint256 endTime\n    );\n\n    event AuctionAuditResult(\n        address indexed auction,\n        address seller,\n        address indexed nftAddress,\n        uint256 indexed tokenId,\n        address winner,\n        uint256 winningBid,\n        uint256 time,\n        bool pass\n    );\n\n    // if winner did not pay, in the event listener, change the deposit placed event record (boolean winnerWithdrawal to false)\n    event AuctionClosed(\n        address indexed auction,\n        address seller,\n        address indexed nftAddress,\n        uint256 indexed tokenId,\n        uint256 closeTime,\n        address winner,\n        uint256 winningBid,\n        Constants.AuctionEndState endState\n    );\n\n    event AuctionDepositPlaced(\n        address indexed auction,\n        address indexed nftAddress,\n        uint256 indexed tokenId,\n        address bidder,\n        uint256 depositAmount,\n        uint256 depositTime\n    );\n\n    event AuctionDepositRetrieved(\n        address indexed auction,\n        address indexed nftAddress,\n        uint256 indexed tokenId,\n        address bidder,\n        uint256 retrieveAmount,\n        uint256 retrievalTime\n    );\n\n    event AuctionBidPlaced(\n        address indexed auction,\n        address indexed nftAddress,\n        uint256 indexed tokenId,\n        address bidder,\n        uint256 bidAmount,\n        uint256 bidTime\n    );\n\n    event AuctionFullSettlementPaid(\n        address indexed auction,\n        address indexed nftAddress,\n        uint256 indexed tokenId,\n        address winner,\n        address seller,\n        uint256 paidAmount,\n        uint256 paidTime\n    );\n\n    event AuctionPendingAudit(\n        address indexed auction,\n        address indexed nftAddress,\n        uint256 indexed tokenId,\n        address winner,\n        address seller,\n        uint256 paidAmount,\n        uint256 paidTime\n    );\n\n    event SellerEarningsRetrieved(\n        address indexed auction,\n        address indexed nftAddress,\n        uint256 indexed tokenId,\n        address seller,\n        uint256 retrieveAmount,\n        uint256 retrievalTime\n    );\n\n    event PendingSellerEarningsRetrieval(\n        address indexed auction,\n        address indexed nftAddress,\n        uint256 indexed tokenId,\n        address seller,\n        uint256 highestBid\n    );\n\n    event WinnerPaymentRefunded(\n        address indexed auction,\n        address indexed nftAddress,\n        uint256 indexed tokenId,\n        address winner,\n        uint256 refundAmount,\n        uint256 retrievalTime\n    );\n\n    event PendingWinnerPaymentRefund(\n        address indexed auction,\n        address indexed nftAddress,\n        uint256 indexed tokenId,\n        address winner,\n        uint256 fullSettlement\n    );\n\n    event PlatformEarnings(\n        address platformOwner,\n        address indexed payer,\n        address indexed auction,\n        Constants.PlatformEarnings indexed earningType,\n        uint256 time\n    );\n\n    function emitAuctionRegistered(\n        address _auction,\n        address _seller,\n        address _nftAddress,\n        uint256 _tokenId,\n        uint256 _registerTime\n    ) public {\n        emit AuctionRegistered(\n            _auction,\n            _seller,\n            _nftAddress,\n            _tokenId,\n            _registerTime\n        );\n    }\n\n    function emitAuctionStartedBidding(\n        address _auction,\n        address _seller,\n        address _nftAddress,\n        uint256 _tokenId,\n        uint256 _depositWei,\n        uint256 _startTime,\n        uint256 _bidEndTime,\n        uint256 _startingBid\n    ) public onlyAuction(msg.sender) {\n        emit AuctionStartedBidding(\n            _auction,\n            _seller,\n            _nftAddress,\n            _tokenId,\n            _depositWei,\n            _startTime,\n            _bidEndTime,\n            _startingBid\n        );\n    }\n\n    function emitAuctionVerifyingWinner(\n        address _auction,\n        address _seller,\n        address _nftAddress,\n        uint256 _tokenId,\n        address _winner,\n        uint256 _winningBid,\n        uint256 _platformCharge,\n        uint256 _startTime,\n        uint256 _expiryTime\n    ) public onlyAuction(msg.sender) {\n        emit AuctionVerifyingWinner(\n            _auction,\n            _seller,\n            _nftAddress,\n            _tokenId,\n            _winner,\n            _winningBid,\n            _platformCharge,\n            _startTime,\n            _expiryTime\n        );\n    }\n\n    function emitAuctionPendingPayment(\n        address _auction,\n        address _seller,\n        address _nftAddress,\n        uint256 _tokenId,\n        address _winner,\n        uint256 _winningBid,\n        uint256 _startTime,\n        uint256 _expiryTime\n    ) public onlyAuction(msg.sender) {\n        emit AuctionPendingPayment(\n            _auction,\n            _seller,\n            _nftAddress,\n            _tokenId,\n            _winner,\n            _winningBid,\n            _startTime,\n            _expiryTime\n        );\n    }\n\n    function emitAuctionAuditResult(\n        address _auction,\n        address _seller,\n        address _nftAddress,\n        uint256 _tokenId,\n        address _winner,\n        uint256 _winningBid,\n        uint256 _time,\n        bool _pass\n    ) public onlyAuction(msg.sender) {\n        emit AuctionAuditResult(\n            _auction,\n            _seller,\n            _nftAddress,\n            _tokenId,\n            _winner,\n            _winningBid,\n            _time,\n            _pass\n        );\n    }\n\n    function emitAuctionClosed(\n        address _auction,\n        address _seller,\n        address _nftAddress,\n        uint256 _tokenId,\n        uint256 _closeTime,\n        address _winner,\n        uint256 _winningBid,\n        Constants.AuctionEndState _endState\n    ) public onlyAuction(msg.sender) {\n        emit AuctionClosed(\n            _auction,\n            _seller,\n            _nftAddress,\n            _tokenId,\n            _closeTime,\n            _winner,\n            _winningBid,\n            _endState\n        );\n    }\n\n    function emitAuctionDepositPlaced(\n        address _auction,\n        address _nftAddress,\n        uint256 _tokenId,\n        address _bidder,\n        uint256 _depositAmount,\n        uint256 _depositTime\n    ) public onlyAuction(msg.sender) {\n        emit AuctionDepositPlaced(\n            _auction,\n            _nftAddress,\n            _tokenId,\n            _bidder,\n            _depositAmount,\n            _depositTime\n        );\n    }\n\n    function emitAuctionBidPlaced(\n        address _auction,\n        address _nftAddress,\n        uint256 _tokenId,\n        address _bidder,\n        uint256 _bidAmount,\n        uint256 _bidTime\n    ) public onlyAuction(msg.sender) {\n        emit AuctionBidPlaced(\n            _auction,\n            _nftAddress,\n            _tokenId,\n            _bidder,\n            _bidAmount,\n            _bidTime\n        );\n    }\n\n    function emitAuctionFullSettlementPaid(\n        address _auction,\n        address _nftAddress,\n        uint256 _tokenId,\n        address _winner,\n        address _seller,\n        uint256 _paidAmount,\n        uint256 _paidTime\n    ) public onlyAuction(msg.sender) {\n        emit AuctionFullSettlementPaid(\n            _auction,\n            _nftAddress,\n            _tokenId,\n            _winner,\n            _seller,\n            _paidAmount,\n            _paidTime\n        );\n    }\n\n    function emitAuctionPendingAudit(\n        address _auction,\n        address _nftAddress,\n        uint256 _tokenId,\n        address _winner,\n        address _seller,\n        uint256 _paidAmount,\n        uint256 _paidTime\n    ) public onlyAuction(msg.sender) {\n        emit AuctionPendingAudit(\n            _auction,\n            _nftAddress,\n            _tokenId,\n            _winner,\n            _seller,\n            _paidAmount,\n            _paidTime\n        );\n    }\n\n    function emitAuctionDepositRetrieved(\n        address _auction,\n        address _nftAddress,\n        uint256 _tokenId,\n        address _retriever,\n        uint256 _retrieveAmount,\n        uint256 _retrievalTime\n    ) public onlyAuction(msg.sender) {\n        emit AuctionDepositRetrieved(\n            _auction,\n            _nftAddress,\n            _tokenId,\n            _retriever,\n            _retrieveAmount,\n            _retrievalTime\n        );\n    }\n\n    function emitPendingSellerEarningsRetrieval(\n        address _auction,\n        address _nftAddress,\n        uint256 _tokenId,\n        address _seller,\n        uint256 _highestBid\n    ) public onlyAuction(msg.sender) {\n        emit PendingSellerEarningsRetrieval(\n            _auction,\n            _nftAddress,\n            _tokenId,\n            _seller,\n            _highestBid\n        );\n    }\n\n    function emitSellerEarningsRetrieved(\n        address _auction,\n        address _nftAddress,\n        uint256 _tokenId,\n        address _seller,\n        uint256 _retrieveAmount,\n        uint256 _retrievalTime\n    ) public onlyAuction(msg.sender) {\n        emit SellerEarningsRetrieved(\n            _auction,\n            _nftAddress,\n            _tokenId,\n            _seller,\n            _retrieveAmount,\n            _retrievalTime\n        );\n    }\n\n    function emitPendingWinnerPaymentRefund(\n        address _auction,\n        address _nftAddress,\n        uint256 _tokenId,\n        address _winner,\n        uint256 _fullSettlement\n    ) public onlyAuction(msg.sender) {\n        emit PendingWinnerPaymentRefund(\n            _auction,\n            _nftAddress,\n            _tokenId,\n            _winner,\n            _fullSettlement\n        );\n    }\n\n    function emitWinnerPaymentRefunded(\n        address _auction,\n        address _nftAddress,\n        uint256 _tokenId,\n        address _winner,\n        uint256 _refundAmount,\n        uint256 _retrievalTime\n    ) public onlyAuction(msg.sender) {\n        emit WinnerPaymentRefunded(\n            _auction,\n            _nftAddress,\n            _tokenId,\n            _winner,\n            _refundAmount,\n            _retrievalTime\n        );\n    }\n\n    function emitPlatformEarnings(\n        address _platformOwner,\n        address _payer,\n        address _auction,\n        Constants.PlatformEarnings _earningType,\n        uint256 _time\n    ) public onlyAuction(msg.sender) {\n        emit PlatformEarnings(\n            _platformOwner,\n            _payer,\n            _auction,\n            _earningType,\n            _time\n        );\n    }\n}\n\ncontract AuctionRegistry {\n    address public immutable owner;\n    address public auctionManagerAddress;\n    AuctionManager private auctionManager;\n\n    mapping(address => mapping(uint256 => address)) public auctionListings;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) {\n            revert AuctionRegistry_RestrictedOwnerAccess();\n        }\n        _;\n    }\n\n    modifier onlyAuctionManager() {\n        if (msg.sender != auctionManagerAddress) {\n            revert AuctionRegistry__RestrictedManagerAccess();\n        }\n        _;\n    }\n\n    modifier onlyContractFactory() {\n        if (\n            AuctionUtility.getContractType(msg.sender) !=\n            Constants.ContractType.CONTRACT_FACTORY\n        ) {\n            revert AuctionRegistry_RestrictedContractFactoryAccess();\n        }\n        _;\n    }\n\n    function getContractType() public pure returns (Constants.ContractType) {\n        return Constants.ContractType.AUCTION_REGISTRY;\n    }\n\n    function setAuctionManagerAddress(address _auctionManagerAddress)\n        public\n        onlyOwner\n    {\n        auctionManagerAddress = _auctionManagerAddress;\n        auctionManager = AuctionManager(auctionManagerAddress);\n    }\n\n    function registerAuction(\n        address _nftAddress,\n        uint256 _tokenId,\n        address _auctionAddress\n    )\n        public\n        onlyContractFactory\n    {\n        // if NFT id not in map, store the NFT -> address mapping\n        // else if NFT id already exist, update the mapping\n        auctionListings[_nftAddress][_tokenId] = _auctionAddress; // this line does it all\n    }\n\n    // TODO: registerTechnician\n}\n\ncontract AuctionKeeper is KeeperCompatibleInterface {\n    address public immutable owner;\n    address public auctionManagerAddress;\n    AuctionManager private auctionManager;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) {\n            revert AuctionRegistry_RestrictedOwnerAccess();\n        }\n        _;\n    }\n\n    function getContractType() public pure returns (Constants.ContractType) {\n        return Constants.ContractType.AUCTION_KEEPER;\n    }\n\n    function setAuctionManagerAddress(address _auctionManagerAddress)\n        public\n        onlyOwner\n    {\n        auctionManagerAddress = _auctionManagerAddress;\n        auctionManager = AuctionManager(auctionManagerAddress);\n    }\n\n    function checkUpkeep(bytes calldata checkData)\n        external\n        view\n        override\n        returns (bool upkeepNeeded, bytes memory performData)\n    {\n        if (keccak256(checkData) == keccak256(hex\"01\")) {\n            address[] memory biddingAuctions = auctionManager\n                .getBiddingAuctions();\n            upkeepNeeded = false;\n            performData = checkData;\n            for (uint i = 0; i < biddingAuctions.length; i++) {\n                if (Auction(biddingAuctions[i]).getBidTimeLeft() == 0) {\n                    upkeepNeeded = true;\n                }\n            }\n            return (upkeepNeeded, performData);\n        }\n\n        if (keccak256(checkData) == keccak256(hex\"02\")) {\n            address[] memory verifyWinnerAuctions = auctionManager\n                .getVerifyWinnerAuctions();\n            upkeepNeeded = false;\n            performData = checkData;\n            for (uint i = 0; i < verifyWinnerAuctions.length; i++) {\n                if (Auction(verifyWinnerAuctions[i]).getVerifyTimeLeft() == 0) {\n                    upkeepNeeded = true;\n                }\n            }\n            return (upkeepNeeded, performData);\n        }\n\n        if (keccak256(checkData) == keccak256(hex\"03\")) {\n            address[] memory pendingPaymentAuctions = auctionManager\n                .getPendingPaymentAuctions();\n            upkeepNeeded = false;\n            performData = checkData;\n            for (uint i = 0; i < pendingPaymentAuctions.length; i++) {\n                if (\n                    Auction(pendingPaymentAuctions[i]).getPaymentTimeLeft() == 0\n                ) {\n                    upkeepNeeded = true;\n                }\n            }\n            return (upkeepNeeded, performData);\n        }\n    }\n\n    function performUpkeep(bytes calldata performData) external override {\n        address[] memory biddingAuctions = auctionManager.getBiddingAuctions();\n        if (keccak256(performData) == keccak256(hex\"01\")) {\n            for (uint i = 0; i < biddingAuctions.length; i++) {\n                if (Auction(biddingAuctions[i]).getBidTimeLeft() == 0) {\n                    Auction(biddingAuctions[i]).endBidding();\n                }\n            }\n        }\n\n        if (keccak256(performData) == keccak256(hex\"02\")) {\n            address[] memory verifyWinnerAuctions = auctionManager\n                .getVerifyWinnerAuctions();\n            for (uint i = 0; i < verifyWinnerAuctions.length; i++) {\n                if (Auction(verifyWinnerAuctions[i]).getVerifyTimeLeft() == 0) {\n                    Auction(verifyWinnerAuctions[i]).verifyWinner(false);\n                }\n            }\n        }\n\n        if (keccak256(performData) == keccak256(hex\"03\")) {\n            address[] memory pendingPaymentAuctions = auctionManager\n                .getPendingPaymentAuctions();\n            for (uint i = 0; i < pendingPaymentAuctions.length; i++) {\n                if (\n                    Auction(pendingPaymentAuctions[i]).getPaymentTimeLeft() == 0\n                ) {\n                    Auction(pendingPaymentAuctions[i]).closeAuction(\n                        Constants.AuctionEndState.PAYMENT_OVERDUE\n                    );\n                }\n            }\n        }\n    }\n}\n\ncontract AuctionManager {\n    address public immutable owner;\n    address[] public biddingAuctions;\n    address[] public verifyWinnerAuctions;\n    address[] public pendingPaymentAuctions;\n    address auctionRegistryAddress;\n    address eventEmitterAddress;\n    address auctionKeeperAddress;\n    address contractFactoryAddress;\n\n    constructor(\n        address _auctionRegistryAddress,\n        address _eventEmitterAddress,\n        address _auctionKeeperAddress,\n        address _contractFactoryAddress\n    ) {\n        owner = msg.sender;\n        auctionRegistryAddress = _auctionRegistryAddress;\n        eventEmitterAddress = _eventEmitterAddress;\n        auctionKeeperAddress = _auctionKeeperAddress;\n        contractFactoryAddress = _contractFactoryAddress;\n    }\n\n    function createAuction(address _nftAddress, uint256 _tokenId) external {\n        (bool sent, bytes memory data) = _nftAddress.call( // require vehicleNft exists\n            abi.encodeWithSignature(\"ownerOf(uint256)\", _tokenId)\n        );\n        require(sent, \"Unable to determine nft holder!\"); // require msg.sender == vehicleNft holder\n        address nftOwner = abi.decode(data, (address));\n        require(\n            (msg.sender == nftOwner),\n            \"Auction can only be created by VOC NFT holder!\"\n        );\n\n        ContractFactory contractFactory = ContractFactory(\n            contractFactoryAddress\n        );\n        contractFactory.createAuction(\n            msg.sender,\n            _nftAddress,\n            _tokenId,\n            eventEmitterAddress,\n            auctionKeeperAddress\n        );\n    }\n\n    function getBiddingAuctions() public view returns (address[] memory) {\n        return biddingAuctions;\n    }\n\n    function getVerifyWinnerAuctions() public view returns (address[] memory) {\n        return verifyWinnerAuctions;\n    }\n\n    function getPendingPaymentAuctions()\n        public\n        view\n        returns (address[] memory)\n    {\n        return pendingPaymentAuctions;\n    }\n\n    function getContractType() public pure returns (Constants.ContractType) {\n        return Constants.ContractType.AUCTION_MANAGER;\n    }\n\n    function addBiddingAuction(address _auctionAddress) public {\n        require(\n            AuctionUtility.getContractType(msg.sender) ==\n                Constants.ContractType.AUCTION\n        );\n        // to be called when bidding starts (by Auction.startAuction())\n        biddingAuctions.push(address(_auctionAddress));\n    }\n\n    function removeBiddingAuction(address _auctionAddress) public {\n        require(\n            AuctionUtility.getContractType(msg.sender) ==\n                Constants.ContractType.AUCTION\n        );\n        // to be called when bidding end time reached (by keepers)\n        uint auctionIndex;\n        int searchResult = searchBiddingAuction(_auctionAddress);\n        if (searchResult >= 0) {\n            auctionIndex = uint(searchResult);\n            for (uint i = auctionIndex; i < biddingAuctions.length - 1; i++) {\n                biddingAuctions[i] = biddingAuctions[i + 1];\n            }\n            biddingAuctions.pop();\n        }\n    }\n\n    function addVerifyWinnerAuction(address _auctionAddress) public {\n        require(\n            AuctionUtility.getContractType(msg.sender) ==\n                Constants.ContractType.AUCTION\n        );\n        //  to be called when bidding end time reached (by keepers)\n        verifyWinnerAuctions.push(address(_auctionAddress));\n    }\n\n    function removeVerifyWinnerAuction(address _auctionAddress) public {\n        require(\n            AuctionUtility.getContractType(msg.sender) ==\n                Constants.ContractType.AUCTION\n        );\n        // to be called when winner paid (by Auction.payFullSettlement()) / payment expiry time reached (by keepers)\n        uint auctionIndex;\n        int searchResult = searchVerifyWinnerAuction(_auctionAddress);\n        if (searchResult >= 0) {\n            auctionIndex = uint(searchResult);\n            for (\n                uint i = auctionIndex;\n                i < verifyWinnerAuctions.length - 1;\n                i++\n            ) {\n                verifyWinnerAuctions[i] = verifyWinnerAuctions[i + 1];\n            }\n            verifyWinnerAuctions.pop();\n        }\n    }\n\n    function addPendingPaymentAuction(address _auctionAddress) public {\n        require(\n            AuctionUtility.getContractType(msg.sender) ==\n                Constants.ContractType.AUCTION\n        );\n        // to be called when bidding end time reached (by keepers)\n        pendingPaymentAuctions.push(address(_auctionAddress));\n    }\n\n    function removePendingPaymentAuction(address _auctionAddress) public {\n        require(\n            AuctionUtility.getContractType(msg.sender) ==\n                Constants.ContractType.AUCTION\n        );\n        // to be called when winner paid (by Auction.payFullSettlement()) / payment expiry time reached (by keepers)\n        uint auctionIndex;\n        int searchResult = searchPendingPaymentAuction(_auctionAddress);\n        if (searchResult >= 0) {\n            auctionIndex = uint(searchResult);\n            for (\n                uint i = auctionIndex;\n                i < pendingPaymentAuctions.length - 1;\n                i++\n            ) {\n                pendingPaymentAuctions[i] = pendingPaymentAuctions[i + 1];\n            }\n            pendingPaymentAuctions.pop();\n        }\n    }\n\n    function searchBiddingAuction(address _auctionAddress)\n        public\n        view\n        returns (int)\n    {\n        for (uint i = 0; i < uint(biddingAuctions.length); i++) {\n            if (biddingAuctions[i] == _auctionAddress) {\n                return int(i);\n            }\n        }\n        return -1;\n    }\n\n    function searchVerifyWinnerAuction(address _auctionAddress)\n        public\n        view\n        returns (int)\n    {\n        for (uint i = 0; i < uint(verifyWinnerAuctions.length); i++) {\n            if (verifyWinnerAuctions[i] == _auctionAddress) {\n                return int(i);\n            }\n        }\n        return -1;\n    }\n\n    function searchPendingPaymentAuction(address _auctionAddress)\n        public\n        view\n        returns (int)\n    {\n        for (uint i = 0; i < uint(pendingPaymentAuctions.length); i++) {\n            if (pendingPaymentAuctions[i] == _auctionAddress) {\n                return int(i);\n            }\n        }\n        return -1;\n    }\n}\n\n/*\n1. Seller can start the auction directly or choose to send the vehicle for verification\n2. Seller must set the duration for the auction and the starting price for the auction\n3. Bidder can join the auction by paying a deposit of 500$, the deposit only has to be paid once\n4. The deposit can be reclaimed by bidder after the auction ends,\n    if the bidder lost the auction or \n    the bidder won the auction and settled the full payment of the vehicle\n5. Bidder can bid for the vehicle provided that the new bid is higher than the current highest bid\n6. Seller cannot bid on their own auction\n7. When the highese bid is updated within 60 seconds of the ending time, \n    the duration of the auction will be reset to 3 minutes\n8. The winner of the auction will be the bidder with the highest bid when the auction ends\n9. The ownership of the auction will be transferred to the winner once the winner settled the payment\n10. The payment must be exactly the amount of the winning bid\n11. The payment must be made within 1 day(s) after the auction ends, \n    otherwise payment cannot be made and the NFT will not be transferred\n12. If no one bid on the vehicle after the bidding time is up, the auctin will end with EndState.NO_BIDDER\n*/\ncontract Auction {\n    enum AuctionState {\n        REGISTERED,\n        BIDDING,\n        VERIFYING_WINNER,\n        PENDING_PAYMENT,\n        PENDING_AUDIT,\n        AUCTION_CLOSED\n    }\n\n    address payable public immutable platformOwner;\n    address payable public immutable seller;\n    address public nftAddress;\n    uint256 public tokenId;\n    address private auctionKeeperAddress;\n    address private auctionManagerAddress;\n    AuctionManager private auctionManager;\n    EventEmitter private eventEmitter;\n    uint128 public depositUSD = 1;\n    uint256 public depositWei;\n    uint256 public bidStartTime;\n    uint256 public bidEndTime;\n    uint128 public durationSec;\n    uint256 public verify_startTime;\n    uint256 public verify_expiryTime;\n    uint256 public verify_duration = 1 days;\n    uint256 public payment_startTime;\n    uint256 public payment_expiryTime;\n    uint256 public payment_duration = 1 days;\n    uint256 public platformCharge;\n    AuctionState public currAuctionState = AuctionState.REGISTERED;\n    Constants.AuctionEndState public auctionEndState =\n        Constants.AuctionEndState.NOT_ENDED;\n    uint256 public highestBid;\n    address public highestBidder;\n    bool winnerPaid = false;\n    mapping(address => uint128) public bidderToDeposits;\n    mapping(address => uint256) public addressToProceeds;\n    address[] public depositers;\n\n    constructor(\n        address _platformOwner,\n        address _seller,\n        address _auctionManagerAddress,\n        address _eventEmitterAddress,\n        address _auctionKeeperAddress,\n        address _nftAddress,\n        uint256 _tokenId\n    ) {\n        platformOwner = payable(_platformOwner);\n        seller = payable(_seller);\n        auctionManagerAddress = _auctionManagerAddress;\n        auctionKeeperAddress = _auctionKeeperAddress;\n        auctionManager = AuctionManager(_auctionManagerAddress);\n        eventEmitter = EventEmitter(_eventEmitterAddress);\n        nftAddress = _nftAddress;\n        tokenId = _tokenId;\n        currAuctionState = AuctionState.REGISTERED;\n        depositWei = AuctionUtility.convertUsdToWei(depositUSD);\n        eventEmitter.emitAuctionRegistered(\n            address(this),\n            _seller,\n            _nftAddress,\n            _tokenId,\n            block.timestamp\n        );\n    }\n\n    modifier onlySeller() {\n        if (msg.sender != seller) {\n            revert Auction_RestrictedSellerAccess();\n        }\n        _;\n    }\n\n    modifier onlySellerOrKeeper() {\n        if ((msg.sender != seller) && (msg.sender != auctionKeeperAddress)) {\n            revert Auction_RestrictedSellerAccess();\n        }\n        _;\n    }\n\n    modifier notForSeller() {\n        if (msg.sender == seller) {\n            revert Auction_SelfBiddingIsNotAllowed();\n        }\n        _;\n    }\n\n    modifier onlyAuthority(address _user) {\n        (bool success, bytes memory data) = nftAddress.call(\n            abi.encodeWithSignature(\"getAuthorityAddress()\")\n        );\n        require(success, \"Unable to determine the contract type!\");\n        address authority = abi.decode(data, (address));\n        if (_user != authority) {\n            revert Auction_UnauthorizedAccess();\n        }\n        _;\n    }\n\n    modifier onlyNftContract() {\n        require(msg.sender == nftAddress);\n        _;\n    }\n\n    function getContractType() public pure returns (Constants.ContractType) {\n        return Constants.ContractType.AUCTION;\n    }\n\n    function inRegisteredState() public view returns (bool) {\n        if (currAuctionState == AuctionState.REGISTERED) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function inBiddingState() public view returns (bool) {\n        if (currAuctionState == AuctionState.BIDDING) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function inVerifyWinnerState() public view returns (bool) {\n        if (currAuctionState == AuctionState.VERIFYING_WINNER) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function inPendingPaymentState() public view returns (bool) {\n        if (currAuctionState == AuctionState.PENDING_PAYMENT) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function inPendingAuditState() public view returns (bool) {\n        if (currAuctionState == AuctionState.PENDING_AUDIT) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function inClosedState() public view returns (bool) {\n        if (currAuctionState == AuctionState.AUCTION_CLOSED) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function startAuction(uint128 _durationSec, uint128 _startingBid) external {\n        require(inRegisteredState(), \"Auction not in Registered state!\");\n        require(msg.sender == seller, \"Requires owner!\");\n        require(_startingBid > 0, \"Start bid < 0!\");\n        bidStartTime = block.timestamp;\n        bidEndTime = bidStartTime + _durationSec;\n        durationSec = _durationSec;\n        highestBid = _startingBid;\n        currAuctionState = AuctionState.BIDDING;\n\n        eventEmitter.emitAuctionStartedBidding(\n            address(this),\n            seller,\n            nftAddress,\n            tokenId,\n            depositWei,\n            bidStartTime,\n            bidEndTime,\n            _startingBid\n        );\n        auctionManager.addBiddingAuction(address(this));\n    }\n\n    function endBidding() public {\n        require(inBiddingState(), \"Illegal state!\");\n        require(block.timestamp >= bidEndTime, \"Bid time > 0!\");\n        if (highestBidder == address(0x0)) {\n            closeAuction(Constants.AuctionEndState.NO_BIDDER);\n        } else {\n            currAuctionState = AuctionState.VERIFYING_WINNER;\n            verify_startTime = block.timestamp;\n            verify_expiryTime = verify_startTime + verify_duration;\n            platformCharge = AuctionUtility.getPlatformCharge(highestBid);\n            eventEmitter.emitAuctionVerifyingWinner(\n                address(this),\n                seller,\n                nftAddress,\n                tokenId,\n                highestBidder,\n                highestBid,\n                platformCharge,\n                verify_startTime,\n                verify_expiryTime\n            );\n            auctionManager.addVerifyWinnerAuction(address(this));\n            for (uint i = 0; i < depositers.length; i++) {\n                // return deposit, except winner\n                address account = depositers[i];\n                if (account == highestBidder) {\n                    break;\n                }\n                uint128 depositBalance = bidderToDeposits[account];\n                if (depositBalance == 0) {\n                    break;\n                }\n                bidderToDeposits[account] = 0;\n                (bool sent, ) = payable(account).call{value: depositBalance}(\n                    \"\"\n                );\n                require(sent, \"ETH transfer failed!\");\n                eventEmitter.emitAuctionDepositRetrieved(\n                    address(this),\n                    nftAddress,\n                    tokenId,\n                    account,\n                    depositBalance,\n                    block.timestamp\n                );\n            }\n        }\n        auctionManager.removeBiddingAuction(address(this));\n    }\n\n    function verifyWinner(bool approveWinningBid) external onlySellerOrKeeper {\n        // when timer's up, keepers call this function, verifyWinner(false)\n        require(inVerifyWinnerState(), \"Illegal state!\");\n        if (approveWinningBid) {\n            payment_startTime = block.timestamp;\n            payment_expiryTime = payment_startTime + payment_duration;\n            currAuctionState = AuctionState.PENDING_PAYMENT;\n            eventEmitter.emitAuctionPendingPayment(\n                address(this),\n                seller,\n                nftAddress,\n                tokenId,\n                highestBidder,\n                highestBid,\n                payment_startTime,\n                payment_expiryTime\n            );\n            auctionManager.removeVerifyWinnerAuction(address(this));\n            auctionManager.addPendingPaymentAuction(address(this));\n        } else {\n            closeAuction(Constants.AuctionEndState.REJECTED_BY_SELLER);\n            auctionManager.removeVerifyWinnerAuction(address(this));\n            // refund deposit to winner\n        }\n    }\n\n    function closeAuction(Constants.AuctionEndState _endState) public {\n        // can only be closed when the winner pays or the payment pending expired (chainlink keepers trigger)\n\n        if (_endState == Constants.AuctionEndState.NO_BIDDER) {\n            require(\n                currAuctionState == AuctionState.BIDDING,\n                \"Illegal state transition!\"\n            );\n            require(getBidTimeLeft() == 0, \"auction still bidding!\");\n            require(\n                highestBidder == address(0x0),\n                \"closeAuction.NO_BIDDER must not have winner!\"\n            );\n            eventEmitter.emitPlatformEarnings(\n                platformOwner,\n                highestBidder,\n                address(this),\n                Constants.PlatformEarnings.NO_EARNINGS,\n                block.timestamp\n            );\n        } else if (_endState == Constants.AuctionEndState.REJECTED_BY_SELLER) {\n            require(\n                currAuctionState == AuctionState.VERIFYING_WINNER,\n                \"illegal state transition!\"\n            );\n            require(\n                msg.sender == seller ||\n                    AuctionUtility.getContractType(msg.sender) ==\n                    Constants.ContractType.AUCTION_KEEPER,\n                \"closeAuction requires seller or keeper!\"\n            );\n            eventEmitter.emitPlatformEarnings(\n                platformOwner,\n                highestBidder,\n                address(this),\n                Constants.PlatformEarnings.NO_EARNINGS,\n                block.timestamp\n            );\n        } else if (_endState == Constants.AuctionEndState.PAYMENT_OVERDUE) {\n            require(\n                currAuctionState == AuctionState.PENDING_PAYMENT,\n                \"illegal state transition!\"\n            );\n            require(\n                msg.sender == seller ||\n                    AuctionUtility.getContractType(msg.sender) ==\n                    Constants.ContractType.AUCTION_KEEPER,\n                \"closeAuction requires seller or keeper!\"\n            );\n            require(winnerPaid == false, \"winner already paid!\");\n            uint128 depositBalance = bidderToDeposits[highestBidder];\n            bidderToDeposits[highestBidder] = 0;\n            (bool sent, ) = payable(seller).call{value: depositBalance}(\"\"); // transfer winner's deposit to seller (as compensation)\n            require(sent, \"ETH transfer failed!\");\n            eventEmitter.emitAuctionDepositRetrieved(\n                address(this),\n                nftAddress,\n                tokenId,\n                seller,\n                depositBalance,\n                block.timestamp\n            );\n        } else if (\n            (_endState == Constants.AuctionEndState.OWNERSHIP_TRANSFERRED) ||\n            (_endState == Constants.AuctionEndState.AUDIT_REJECTED)\n        ) {\n            require(\n                currAuctionState == AuctionState.PENDING_AUDIT,\n                \"illegal state transition!\"\n            );\n            require(msg.sender == nftAddress, \"only Auditor\");\n            if (_endState == Constants.AuctionEndState.AUDIT_REJECTED) {\n                eventEmitter.emitPlatformEarnings(\n                    platformOwner,\n                    highestBidder,\n                    address(this),\n                    Constants.PlatformEarnings.NO_EARNINGS,\n                    block.timestamp\n                );\n            }\n            if (_endState == Constants.AuctionEndState.OWNERSHIP_TRANSFERRED) {\n                eventEmitter.emitPlatformEarnings(\n                    platformOwner,\n                    highestBidder,\n                    address(this),\n                    Constants.PlatformEarnings.FULL_SETTLEMENT,\n                    block.timestamp\n                );\n            }\n        } else {\n            // else if (_endState == Constants.AuctionEndState.CANCELED)\n            require(\n                currAuctionState == AuctionState.REGISTERED,\n                \"illegal state transition!\"\n            );\n            require(msg.sender == seller, \"only seller!\");\n            eventEmitter.emitPlatformEarnings(\n                platformOwner,\n                highestBidder,\n                address(this),\n                Constants.PlatformEarnings.NO_EARNINGS,\n                block.timestamp\n            );\n        }\n\n        currAuctionState = AuctionState.AUCTION_CLOSED;\n        auctionEndState = _endState;\n        eventEmitter.emitAuctionClosed(\n            address(this),\n            seller,\n            nftAddress,\n            tokenId,\n            block.timestamp,\n            highestBidder,\n            highestBid,\n            _endState\n        );\n        if ((_endState == Constants.AuctionEndState.PAYMENT_OVERDUE)) {\n            auctionManager.removePendingPaymentAuction(address(this));\n        }\n    }\n\n    function placeDeposit() external payable notForSeller {\n        require(inBiddingState(), \"Illegal state!\");\n        require((bidderToDeposits[msg.sender] == 0), \"Account deposited!\");\n        require((msg.value >= depositWei), \"Wrong deposit amount!\");\n        bidderToDeposits[msg.sender] += uint128(msg.value);\n        eventEmitter.emitAuctionDepositPlaced(\n            address(this),\n            nftAddress,\n            tokenId,\n            msg.sender,\n            msg.value,\n            block.timestamp\n        );\n        depositers.push(msg.sender);\n    }\n\n    function placeBid(uint256 _bidAmount) external notForSeller {\n        require(inBiddingState(), \"Illegal state!\");\n        require(getBidTimeLeft() > 0, \"Bidding closed!\");\n        require(\n            (bidderToDeposits[msg.sender] >= depositWei),\n            \"Deposit required for bidding!\"\n        );\n        require(_bidAmount > highestBid, \"Bid lower than highest bid!\");\n\n        highestBid = _bidAmount;\n        highestBidder = msg.sender;\n        eventEmitter.emitAuctionBidPlaced(\n            address(this),\n            nftAddress,\n            tokenId,\n            msg.sender,\n            _bidAmount,\n            block.timestamp\n        );\n    }\n\n    function withdrawDeposit() external payable {\n        require(\n            ((msg.sender != highestBidder) ||\n                (msg.sender == highestBidder && winnerPaid == true) ||\n                (msg.sender == highestBidder && inClosedState())),\n            \"Cannot withdraw!\"\n        );\n        // requires bidder to settle full payment for withdrawal (full payment only when the seller accepted the result)\n        // requires bidder to not exceed the expiry date for full payment settlement\n        // close the auction when the expiry date is reached\n        uint128 depositBalance = bidderToDeposits[msg.sender];\n        bidderToDeposits[msg.sender] = 0;\n        (bool sent, ) = payable(msg.sender).call{value: depositBalance}(\"\");\n        require(sent, \"ETH withdrawal failed!\");\n        eventEmitter.emitAuctionDepositRetrieved(\n            address(this),\n            nftAddress,\n            tokenId,\n            msg.sender,\n            depositBalance,\n            block.timestamp\n        );\n    }\n\n    function payFullSettlement() external payable {\n        require(msg.sender == highestBidder, \"Only winner pay!\");\n        require((inPendingPaymentState()), \"Illegal state!\");\n        require(\n            (getPaymentTimeLeft() > 0),\n            \"Payment window for full settlement closed!\"\n        );\n        require(\n            (msg.value == (highestBid + platformCharge)),\n            \"Payment value != (winning bid + platform charge)!\"\n        );\n        require((!winnerPaid), \"You have paid!\");\n        addressToProceeds[seller] = highestBid;\n        addressToProceeds[platformOwner] = platformCharge;\n        winnerPaid = true;\n        auctionManager.removePendingPaymentAuction(address(this));\n        eventEmitter.emitAuctionFullSettlementPaid(\n            address(this),\n            nftAddress,\n            tokenId,\n            highestBidder,\n            seller,\n            msg.value,\n            block.timestamp\n        );\n        eventEmitter.emitAuctionPendingAudit(\n            address(this),\n            nftAddress,\n            tokenId,\n            highestBidder,\n            seller,\n            msg.value,\n            block.timestamp\n        );\n        currAuctionState = AuctionState.PENDING_AUDIT;\n        // return deposit to winner\n        uint128 depositBalance = bidderToDeposits[highestBidder];\n        bidderToDeposits[highestBidder] = 0;\n        (bool sent, ) = payable(highestBidder).call{value: depositBalance}(\"\");\n        require(sent, \"ETH transfer failed!\");\n        eventEmitter.emitAuctionDepositRetrieved(\n            address(this),\n            nftAddress,\n            tokenId,\n            highestBidder,\n            depositBalance,\n            block.timestamp\n        );\n    }\n\n    function withdrawSellerEarnings() external onlySeller {\n        require(\n            (auctionEndState ==\n                Constants.AuctionEndState.OWNERSHIP_TRANSFERRED),\n            \"Ownership not transferred!\"\n        );\n        uint256 proceeds = addressToProceeds[seller];\n        if (proceeds <= 0) {\n            revert Auction_NoProceeds();\n        }\n        addressToProceeds[seller] = 0;\n        (bool sent, ) = payable(seller).call{value: proceeds}(\"\");\n        require(sent, \"ETH transfer failed\");\n        eventEmitter.emitSellerEarningsRetrieved(\n            address(this),\n            nftAddress,\n            tokenId,\n            msg.sender,\n            proceeds,\n            block.timestamp\n        );\n    }\n\n    function refundFullSettlement() external {\n        require(\n            msg.sender == highestBidder,\n            \"Refund can only be made to payer!\"\n        );\n        require(\n            auctionEndState == Constants.AuctionEndState.AUDIT_REJECTED,\n            \"Inegligible for refund!\"\n        );\n        uint256 proceeds = addressToProceeds[seller] +\n            addressToProceeds[platformOwner];\n        if (proceeds <= 0) {\n            revert Auction_NoProceeds();\n        }\n        addressToProceeds[seller] = 0;\n        addressToProceeds[platformOwner] = 0;\n        (bool sent, ) = payable(highestBidder).call{value: (proceeds)}(\"\");\n        require(sent, \"ETH transfer failed\");\n        eventEmitter.emitWinnerPaymentRefunded(\n            address(this),\n            nftAddress,\n            tokenId,\n            msg.sender,\n            proceeds,\n            block.timestamp\n        );\n    }\n\n    function setAuditResult(bool _valid) external onlyNftContract {\n        require(inPendingAuditState());\n        if (_valid == true) {\n            closeAuction(Constants.AuctionEndState.OWNERSHIP_TRANSFERRED);\n            uint256 proceeds = addressToProceeds[platformOwner];\n            addressToProceeds[platformOwner] = 0;\n            (bool sent, ) = payable(platformOwner).call{value: proceeds}(\"\");\n            require(sent, \"ETH transfer failed\");\n            eventEmitter.emitPendingSellerEarningsRetrieval(\n                address(this),\n                nftAddress,\n                tokenId,\n                seller,\n                highestBid\n            );\n        } else {\n            closeAuction(Constants.AuctionEndState.AUDIT_REJECTED);\n            eventEmitter.emitPendingWinnerPaymentRefund(\n                address(this),\n                nftAddress,\n                tokenId,\n                highestBidder,\n                platformCharge + highestBid\n            );\n        }\n        eventEmitter.emitAuctionAuditResult(\n            address(this),\n            seller,\n            nftAddress,\n            tokenId,\n            highestBidder,\n            highestBid,\n            block.timestamp,\n            _valid\n        );\n    }\n\n    function getBidTimeLeft() public view returns (uint256) {\n        if (block.timestamp > bidEndTime) {\n            return 0;\n        } else {\n            return (bidEndTime - block.timestamp);\n        }\n    }\n\n    function getVerifyTimeLeft() public view returns (uint256) {\n        if (block.timestamp > verify_expiryTime) {\n            return 0;\n        } else {\n            return (verify_expiryTime - block.timestamp);\n        }\n    }\n\n    function getPaymentTimeLeft() public view returns (uint256) {\n        if (block.timestamp > payment_expiryTime) {\n            return 0;\n        } else {\n            return (payment_expiryTime - block.timestamp);\n        }\n    }\n}\n"
    },
    "libraries/AuctionUtility.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nlibrary AuctionUtility {\n    function getWeiPerUsdRate() internal view returns (uint256) {\n        // for testnet\n        AggregatorV3Interface priceFeed = AggregatorV3Interface(\n            0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e\n        );\n        (, int256 price, , , ) = priceFeed.latestRoundData(); // WeiPerUsd (in 8 decimals)\n        // for local network\n        //int256 price = 132102000000;\n\n        return uint256(price * 1e10);\n    }\n\n    function convertWeiToUsd(uint256 p_weiAmount)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 ethRate = getWeiPerUsdRate();\n        uint256 usdEquivalent = (p_weiAmount * ethRate) / (1e18 * 1e18);\n        return usdEquivalent;\n    }\n\n    function convertUsdToWei(uint256 p_usdAmount)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 ethRate = getWeiPerUsdRate();\n        uint256 weiEquivalent = (1e18 * 1e18) / (p_usdAmount * ethRate);\n        return weiEquivalent;\n    }\n\n    function hourToSec(uint inHours) internal pure returns (uint256 inMinutes) {\n        return (inHours * 60 * 60);\n    }\n\n    function getContractType(address _contractAddress)\n        internal\n        returns (Constants.ContractType)\n    {\n        (bool success, bytes memory data) = _contractAddress.call(\n            abi.encodeWithSignature(\"getContractType()\")\n        );\n        require(success, \"Unable to determine the contract type!\");\n        return abi.decode(data, (Constants.ContractType));\n    }\n\n    function getPlatformCharge(uint256 highestBid)\n        internal\n        pure\n        returns (uint256 platformCharge)\n    {\n        return (highestBid * Constants.platformChargeRate) / 100;\n    }\n}\n\nlibrary Constants {\n    enum ContractType {\n        AUCTION,\n        AUCTION_MANAGER,\n        AUCTION_REGISTRY,\n        CONTRACT_FACTORY,\n        AUCTION_KEEPER\n    }\n\n    enum AuctionEndState {\n        NOT_ENDED,\n        CANCELED,\n        NO_BIDDER,\n        REJECTED_BY_SELLER,\n        PAYMENT_OVERDUE,\n        AUDIT_REJECTED,\n        OWNERSHIP_TRANSFERRED\n    }\n\n    enum PlatformEarnings {\n        NO_EARNINGS, // when auction fail audit or no bidder or seller disagree to sell or cancelled\n        DEPOSIT, // when winner did not pay full settlement\n        FULL_SETTLEMENT // when auction passed audit\n    }\n\n    uint32 internal constant platformChargeRate = 5; // 5 percent\n}\n"
    },
    "@chainlink/contracts/src/v0.8/KeeperCompatible.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./KeeperBase.sol\";\nimport \"./interfaces/KeeperCompatibleInterface.sol\";\n\nabstract contract KeeperCompatible is KeeperBase, KeeperCompatibleInterface {}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface KeeperCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/KeeperBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract KeeperBase {\n  error OnlySimulatedBackend();\n\n  /**\n   * @notice method that allows it to be simulated via eth_call by checking that\n   * the sender is the zero address.\n   */\n  function preventExecution() internal view {\n    if (tx.origin != address(0)) {\n      revert OnlySimulatedBackend();\n    }\n  }\n\n  /**\n   * @notice modifier that allows it to be simulated via eth_call by checking\n   * that the sender is the zero address.\n   */\n  modifier cannotExecute() {\n    preventExecution();\n    _;\n  }\n}\n"
    },
    "contracts/VehicleNft.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract VehicleNft is ERC721, ERC721Burnable {\n    constructor(string memory _name, string memory _symbol)\n        ERC721(_name, _symbol)\n    {\n        authority = msg.sender;\n    }\n\n    modifier onlyAuthority() {\n        require(msg.sender == authority, \"Unauthorized function access!\");\n        _;\n    }\n\n    modifier onlyAuthorityApprovedBurn(uint256 _tokenId) {\n        require(tokenIdToBurnBool[_tokenId] == true, \"NFT burn not approved!\");\n        _;\n    }\n\n    modifier onlyVehicleNotRegistered(string memory _chassisNum) {\n        require(\n            chassisNumToBool[_chassisNum] != true,\n            \"Vehicle already registered!\"\n        );\n        _;\n    }\n\n    event NftMinted(\n        address indexed owner,\n        string tokenURI,\n        uint256 indexed tokenId\n    );\n\n    event NftBurned(address indexed owner, uint256 indexed tokenId);\n\n    event NftTransferred(\n        address indexed prev_Owner,\n        address indexed curr_Owner,\n        uint256 indexed tokenId\n    );\n\n    using Counters for Counters.Counter;\n    address private authority;\n    Counters.Counter private _tokenIds;\n    mapping(uint256 => string) private tokenIdToTokenUri;\n    mapping(string => bool) private chassisNumToBool;\n    mapping(uint256 => bool) public tokenIdToBurnBool;\n    mapping(uint256 => string) public tokenIdToReportUri;\n\n    function registerVehicle(\n        address _owner,\n        string memory _tokenURI,\n        string memory _chassisNum\n    )\n        public\n        onlyAuthority\n        onlyVehicleNotRegistered(_chassisNum)\n        returns (uint256)\n    {\n        _tokenIds.increment();\n\n        uint256 curr_tokenId = _tokenIds.current();\n        tokenIdToTokenUri[curr_tokenId] = _tokenURI;\n        super._mint(_owner, curr_tokenId);\n        chassisNumToBool[_chassisNum] = true;\n        emit NftMinted(_owner, _tokenURI, curr_tokenId);\n\n        return curr_tokenId;\n    }\n\n    function addReport(uint256 _tokenId, string memory _tokenURI) external onlyAuthority {\n        tokenIdToReportUri[_tokenId] = _tokenURI;\n    }\n\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override\n        returns (string memory)\n    {\n        require(\n            _exists(tokenId),\n            \"ERC721Metadata: URI query for nonexistent token\"\n        );\n        return tokenIdToTokenUri[tokenId];\n    }\n\n    function setAuditResult(address _auction, bool _valid)\n        external\n        onlyAuthority\n    {\n        (bool sent, ) = _auction.call(\n            abi.encodeWithSignature(\"setAuditResult(bool)\", _valid)\n        );\n        require(sent, \"unable to send audit result\");\n        if (_valid) {\n            (bool success, bytes memory data) = _auction.call(\n                abi.encodeWithSignature(\"seller()\")\n            );\n            require(success, \"Unable to determine the contract type!\");\n            address seller = abi.decode(data, (address));\n\n            (bool success_2, bytes memory data_2) = _auction.call(\n                abi.encodeWithSignature(\"highestBidder()\")\n            );\n            require(success_2, \"Unable to determine the contract type!\");\n            address winner = abi.decode(data_2, (address));\n\n            (bool success_3, bytes memory data_3) = _auction.call(\n                abi.encodeWithSignature(\"tokenId()\")\n            );\n            require(success_3, \"Unable to determine the contract type!\");\n            uint256 tokenId = abi.decode(data_3, (uint256));\n\n            transferFrom(seller, winner, tokenId);\n        }\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override onlyAuthority {\n        //solhint-disable-next-line max-line-length\n        require(\n            (_isApprovedOrOwner((_msgSender()), tokenId) ||\n                (msg.sender == authority)),\n            \"ERC721: caller is not token owner or approved\"\n        );\n\n        super._transfer(from, to, tokenId);\n        emit NftTransferred(from, to, tokenId);\n    }\n\n    function approveBurn(uint256 _tokenId) public onlyAuthority {\n        require(ownerOf(_tokenId) != address(0x0), \"Invalid token Id!\");\n        tokenIdToBurnBool[_tokenId] = true;\n    }\n\n    function burn(uint256 _tokenId) public override onlyAuthorityApprovedBurn(_tokenId) {\n        require(msg.sender == (ownerOf(_tokenId)) || msg.sender == authority, \"Burn can only be called by owner or authority\");\n        //solhint-disable-next-line max-line-length\n        address owner = ERC721.ownerOf(_tokenId);\n        _burn(_tokenId);\n        emit NftBurned(owner, _tokenId);\n    }\n\n    function getAuthorityAddress() public view returns (address) {\n        return authority;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0-rc.1) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any (single) token transfer. This includes minting and burning.\n     * See {_beforeConsecutiveTokenTransfer}.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any (single) transfer of tokens. This includes minting and burning.\n     * See {_afterConsecutiveTokenTransfer}.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called before consecutive token transfers.\n     * Calling conditions are similar to {_beforeTokenTransfer}.\n     *\n     * The default implementation include balances updates that extensions such as {ERC721Consecutive} cannot perform\n     * directly.\n     */\n    function _beforeConsecutiveTokenTransfer(\n        address from,\n        address to,\n        uint256, /*first*/\n        uint96 size\n    ) internal virtual {\n        if (from != address(0)) {\n            _balances[from] -= size;\n        }\n        if (to != address(0)) {\n            _balances[to] += size;\n        }\n    }\n\n    /**\n     * @dev Hook that is called after consecutive token transfers.\n     * Calling conditions are similar to {_afterTokenTransfer}.\n     */\n    function _afterConsecutiveTokenTransfer(\n        address, /*from*/\n        address, /*to*/\n        uint256, /*first*/\n        uint96 /*size*/\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0-rc.1) (token/ERC721/extensions/ERC721Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be burned (destroyed).\n */\nabstract contract ERC721Burnable is Context, ERC721 {\n    /**\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\n     *\n     * Requirements:\n     *\n     * - The caller must own `tokenId` or be an approved operator.\n     */\n    function burn(uint256 tokenId) public virtual {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _burn(tokenId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0-rc.1) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0-rc.1) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0-rc.1) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0-rc.1) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "yul": false
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}